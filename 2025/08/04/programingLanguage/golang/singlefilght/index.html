<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang 中的 singleflight | LiamRyan 自救指南</title><meta name="author" content="LiamRyan"><meta name="copyright" content="LiamRyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景 一般情况下我们在写一写对外的服务的时候都会有一层 cache 作为缓存，用来减少底层数据库的压力，但是在遇到例如 redis 抖动或者其他情况可能会导致大量的 cache miss 出现。 假如我们要访问一个文件，但是由于各种问题，这个请求发送了 1000 次，如果不做处理，让他直接访问缓存或者直接访问数据库，那么就会显著增大后端压力，降低并发性能。 这个时候我们就可以使用 singlefl">
<meta property="og:type" content="article">
<meta property="og:title" content="golang 中的 singleflight">
<meta property="og:url" content="http://iuun05.github.io/2025/08/04/programingLanguage/golang/singlefilght/index.html">
<meta property="og:site_name" content="LiamRyan 自救指南">
<meta property="og:description" content="背景 一般情况下我们在写一写对外的服务的时候都会有一层 cache 作为缓存，用来减少底层数据库的压力，但是在遇到例如 redis 抖动或者其他情况可能会导致大量的 cache miss 出现。 假如我们要访问一个文件，但是由于各种问题，这个请求发送了 1000 次，如果不做处理，让他直接访问缓存或者直接访问数据库，那么就会显著增大后端压力，降低并发性能。 这个时候我们就可以使用 singlefl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://iuun05.github.io/img/20220513011040_fc477.png">
<meta property="article:published_time" content="2025-08-04T07:20:01.000Z">
<meta property="article:modified_time" content="2025-08-13T15:04:24.455Z">
<meta property="article:author" content="LiamRyan">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="singleflight">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://iuun05.github.io/img/20220513011040_fc477.png"><link rel="shortcut icon" href="/GWdBd10WcAAyRuc.jpg"><link rel="canonical" href="http://iuun05.github.io/2025/08/04/programingLanguage/golang/singlefilght/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.0.0-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang 中的 singleflight',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-13 23:04:24'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/20220513011040_fc477.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/ac345982b2b7d0a27aba85bc8def76094b369aa4.jpg);"><nav id="nav"><span id="blog-info"><a href="/" title="LiamRyan 自救指南"><img class="site-icon" src="/img/20220513011040_fc477.png" alt="Logo"/><span class="site-name">LiamRyan 自救指南</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">golang 中的 singleflight</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-04T07:20:01.000Z" title="发表于 2025-08-04 15:20:01">2025-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-13T15:04:24.455Z" title="更新于 2025-08-13 23:04:24">2025-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E7%94%A8%E5%BA%93%E6%96%87%E4%BB%B6/">实用库文件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E7%94%A8%E5%BA%93%E6%96%87%E4%BB%B6/Golang/">Golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="golang 中的 singleflight"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="背景">背景</h2>
<p>一般情况下我们在写一写对外的服务的时候都会有一层 cache 作为缓存，用来减少底层数据库的压力，但是在遇到例如 redis 抖动或者其他情况可能会导致大量的 cache miss 出现。</p>
<p>假如我们要访问一个文件，但是由于各种问题，这个请求发送了 1000 次，如果不做处理，让他直接访问缓存或者直接访问数据库，那么就会显著增大后端压力，降低并发性能。</p>
<p>这个时候我们就可以使用 singleflight 库文件，直译过来叫做单飞，主要作用就是把一组相同的请求合并为一个请求，实际上只会请求一次，这样会显著减少数据库和缓存的压力。</p>
<h2 id="原理">原理</h2>
<p>singleflight 一共提供了三种接口，具体的说明在这里 <a target="_blank" rel="noopener" href="https://pkg.go.dev/golang.org/x/sync/singleflight">singleflight</a>：</p>
<ul>
<li>func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool)：执行并返回给定函数的结果，<strong>确保给定键一次只执行一次</strong>。如果有重复的进来，<strong>重复的调用者等待原始函数完成并收到相同的结果</strong>。共享的返回值指示是否将v提供给多个调用者。</li>
<li>func (g *Group) DoChan(key string, fn func() (interface{}, error)) &lt;-chan Result：DoChan与Do类似，但返回一个通道，该通道将在结果准备就绪时接收结果。（<strong>与 Do 的返回结果不同</strong>）</li>
<li>func (g *Group) Forget(key string)：告诉 singleflight 删除一个键。未来对该键的Do调用将调用该函数，而不是等待较早的调用完成。</li>
</ul>
<h3 id="基础数据结构">基础数据结构</h3>
<p>一共有两组元素，有一个 map 来保存映射关系，来合并重复请求，还有一个 mutex 锁来保护 m，因为在 golang 中 map 不是并发安全的。</p>
<blockquote>
<p>map 内部没有锁机制，如果当扩容的时候，把数据复制到 oldbucket 中，然后突然一个 goroutine 写入一个数据，有可能 new bucket 还没有初始化，或者打断了迁移的状态等，那么会造成数据混乱</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group represents a class of work and forms a namespace in</span></span><br><span class="line"><span class="comment">// which units of work can be executed with duplicate suppression.</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]*call <span class="comment">// lazily initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map 是一个关于 key -&gt; call 的映射，call 是用来表示一次&quot;正在进行或已经完成&quot;的共享请求操作的结构体。这个机制用于避免缓存击穿时多个 goroutine 重复请求同一个资源。多个 goroutine 请求相同的 key，只会触发一个 Do 调用，其他的都会等待这个 call 的结果。call 的数据结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call is an in-flight or completed singleflight.Do call</span></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These fields are written once before the WaitGroup is done</span></span><br><span class="line">    <span class="comment">// and are only read after the WaitGroup is done.</span></span><br><span class="line">    <span class="comment">// 只会写入一次值</span></span><br><span class="line">    val any</span><br><span class="line">    err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// These fields are read and written with the singleflight</span></span><br><span class="line">    <span class="comment">// mutex held before the WaitGroup is done, and are read but</span></span><br><span class="line">    <span class="comment">// not written after the WaitGroup is done.</span></span><br><span class="line">    <span class="comment">// 统计调用次数以及需要返回的 channel</span></span><br><span class="line">    dups  <span class="type">int</span></span><br><span class="line">    chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-和-dochan">Do 和 DoChan</h3>
<p>Do 和 DoChan 的功能都是向上提供一个 doCall 的接口，只是返回值不同罢了。在底层代码中只有在存在多次请求的时候才有部分区别。</p>
<p><strong>相同：</strong></p>
<ul>
<li>懒加载，只会在被使用的时候才会加载。</li>
<li>都是共享相同结果，来直接进行返回。</li>
<li>内部更新相似，除了 chans 不同</li>
</ul>
<p><strong>不同：</strong></p>
<ul>
<li>主要是 Do 使用的是 wg 来进行阻塞，DoChan 直接用 channel 的阻塞特性来进行阻塞。</li>
<li>返回方式不同，一个返回 (val， err， shared)，另一个返回 channel</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do executes and returns the results of the given function, making</span></span><br><span class="line"><span class="comment">// sure that only one execution is in-flight for a given key at a</span></span><br><span class="line"><span class="comment">// time. If a duplicate comes in, the duplicate caller waits for the</span></span><br><span class="line"><span class="comment">// original to complete and receives the same results.</span></span><br><span class="line"><span class="comment">// The return value shared indicates whether v was given to multiple callers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (v <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>, shared <span class="type">bool</span>) &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">            <span class="built_in">panic</span>(e)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">            runtime.Goexit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    g.doCall(c, key, fn)</span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="docall">doCall</h3>
<p>这部分代码是 fn 函数的实际执行逻辑。当 fn 执行完成后，会调用 wg.Done() 来唤醒因调用 Do 而阻塞等待的其他 goroutine。随后，会从 m.calls 中删除当前 key，以避免该条目污染后续的请求。最后，它会向所有等待在 DoChan 的 channel 中的 goroutine 发送结果，以确保并发调用者能够获得相同的返回值。</p>
<p>这一版感觉非常的复杂，和我之前在 github 上看到的一版不同。链接在这 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/internal/singleflight/singleflight.go">singleflight</a>，可以看到实现非常简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doCall handles the single call for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (any, <span class="type">error</span>)) &#123;</span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line"></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    <span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">        <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">        ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，下面一版加了很多关于 panic 的处理，有点头皮发麻。但是大致的意思是很明确的——<strong>显式触发 panic，让程序在 fn 中 panic 后能继续崩溃退出，而不是因为 recover 导致主 goroutine 继续执行，从而让等待的 goroutine 永远收不到结果，最终造成死锁</strong>。</p>
<p>处理方法是：<strong>宁愿整个程序 crash，也不能因为 panic 被吞而导致多个请求 goroutine 被永远挂起</strong>。</p>
<p>注释里面有一份<a target="_blank" rel="noopener" href="https://go-review.googlesource.com/c/sync/+/134395">文档</a>，我先把他贴出来：</p>
<blockquote>
<p>errgroup: rethink concurrency patterns</p>
<p>A few events in the last couple of weeks have prompted me to revise errgroup a bit.</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://golang.org/cl/131815">https://golang.org/cl/131815</a> pointed out that errgroup can cause tests to deadlock if t.Fatal or t.Skip is called in one of the goroutines in the group. While we do not recommend t.Fatal or t.Skip outside the test’s main goroutine, it’s difficult to debug such a deadlock and arguably more useful if we build in some sort of support.</li>
<li>In my GopherCon talk, “Rethinking Classical Concurrency Patterns”, I recommended that API authors “make concurrency an internal detail.” In multiple discussions after the talk, folks asked me how to handle panics in goroutines, and I realized that making concurrency an internal detail requires that we propagate panics (and runtime.Goexit calls) back to the caller’s goroutine.</li>
<li>Kevin Burke asked whether I would be interested in a proposal to move errgroup to the standard library. I replied that there is at least one open problem with the API: namely, that unlike sync.WaitGroup, an errgroup.Group cannot be reused after Wait is called. My reasoning was that the associated context.CancelFunc must be called in order to avoid leaking resources, and I did not want to expand the required API surface with a boilerplate cancel call.<br>
I looked at the examples again with that reasoning in mind, and realized that it is almost always more robust to defer two operations: “cancel the goroutines” and “wait for the goroutine to exit”. A single call suffices for both, and simplifies many functions that return early on error.</li>
</ol>
<p>Updates golang/go#15758.<br>
Updates golang/go#25448.<br>
Change-Id: Ica4ce9e4569867d1485f19365af76ca010d7b6aa</p>
</blockquote>
<p>为了更好的处理子协程的异常情况，建议使用 defer 延迟执行两种操作，<strong>“取消 goroutine” 和 “等待 goroutine 全部退出”</strong>。doCall 部分也是这样来实现的。</p>
<blockquote>
<p>I looked at the examples again with that reasoning in mind, and realized that it is almost always more robust to defer two operations: “cancel the goroutines” and “wait for the goroutine to exit”.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doCall handles the single call for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> doCall(c *call, key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) &#123;</span><br><span class="line">    normalReturn := <span class="literal">false</span></span><br><span class="line">    recovered := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// use double-defer to distinguish panic from runtime.Goexit,</span></span><br><span class="line">    <span class="comment">// more details see https://golang.org/cl/134395</span></span><br><span class="line">    <span class="comment">// 双重 defer 区别 panic 和 runtime.Goexit（两者在语义上都不会走完函数逻辑）</span></span><br><span class="line">    <span class="comment">// runtime.Goexit 不会触发 recover()，这也就是为什么要用 double-defer 来判断</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// the given function invoked runtime.Goexit</span></span><br><span class="line">        <span class="comment">// 如果没有正常返回，也没有触发 recover，则说明是 runtime.Goexit 导致的返回。</span></span><br><span class="line">        <span class="keyword">if</span> !normalReturn &amp;&amp; !recovered &#123;</span><br><span class="line">            c.err = errGoexit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态清理部分</span></span><br><span class="line">        g.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">        <span class="comment">// 唤醒等待的的 goroutine</span></span><br><span class="line">        c.wg.Done()</span><br><span class="line">        <span class="comment">// 删除 call 对应的 key，防止内存泄露和污染下一次请求。</span></span><br><span class="line">        <span class="keyword">if</span> g.m[key] == c &#123;</span><br><span class="line">            <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我对这段代码的理解是，如果在 fn 发生了 panic，</span></span><br><span class="line">        <span class="comment">// recover 后并不会干涉到 doCall 的执行，fn 只会返回一个 error</span></span><br><span class="line">        <span class="comment">// 如果有多个 goroutine 正在等待结果，需要保证 doCall 能 crash 掉，对外做出反应，让等待着的 goroutine 能正常退出，防止苦等而造成的锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决方法就是在一个新的 goroutine 中触发 panic</span></span><br><span class="line">        <span class="comment">// 并让当前 goroutine 阻塞不退出，从而保证崩溃信息完整且所有等待者都能感知异常。</span></span><br><span class="line">        <span class="keyword">if</span> e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">            <span class="comment">// In order to prevent the waiting channels from being blocked forever,</span></span><br><span class="line">            <span class="comment">// needs to ensure that this panic cannot be recovered.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(c.chans) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 为什么会新开一个 goroutine 呢？</span></span><br><span class="line">                <span class="comment">// 在新的 goroutine 里触发 panic，可以让这个新的 goroutine 崩溃</span></span><br><span class="line">                <span class="comment">// 操作系统或运行时会把这个 panic 视为程序异常终止，产生完整的崩溃日志（crash dump）。</span></span><br><span class="line">                <span class="keyword">go</span> <span class="built_in">panic</span>(e)</span><br><span class="line">                <span class="comment">// Keep this goroutine around so that it will appear in the crash dump.</span></span><br><span class="line">                <span class="keyword">select</span> &#123;&#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有等待的 channel，直接触发 panic</span></span><br><span class="line">                <span class="built_in">panic</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.err == errGoexit &#123;</span><br><span class="line">            <span class="comment">// Already in the process of goexit, no need to call again</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Normal return</span></span><br><span class="line">            <span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">                ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用闭包做一层包裹，内层 defer 用于捕获 panic</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">                <span class="comment">// Ideally, we would wait to take a stack trace until we&#x27;ve determined</span></span><br><span class="line">                <span class="comment">// whether this is a panic or a runtime.Goexit.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Unfortunately, the only way we can distinguish the two is to see</span></span><br><span class="line">                <span class="comment">// whether the recover stopped the goroutine from terminating, and by</span></span><br><span class="line">                <span class="comment">// the time we know that, the part of the stack trace relevant to the</span></span><br><span class="line">                <span class="comment">// panic has been discarded.</span></span><br><span class="line">                <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">                    c.err = newPanicError(r)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        c.val, c.err = fn()</span><br><span class="line">        normalReturn = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !normalReturn &#123;</span><br><span class="line">        recovered = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer 执行顺序是先执行匿名函数中的 defer，其次才是最外面的 defer</p>
<blockquote>
<p>defer 的执行是先进后出</p>
</blockquote>
<h3 id="forget">Forget</h3>
<p>简单来说就是删除 map 中的 key，没有什么特别的地方。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forget tells the singleflight to forget about a key.  Future calls</span></span><br><span class="line"><span class="comment">// to Do for this key will call the function rather than waiting for</span></span><br><span class="line"><span class="comment">// an earlier call to complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Forget(key <span class="type">string</span>) &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://iuun05.github.io">LiamRyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://iuun05.github.io/2025/08/04/programingLanguage/golang/singlefilght/">http://iuun05.github.io/2025/08/04/programingLanguage/golang/singlefilght/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://iuun05.github.io" target="_blank">LiamRyan 自救指南</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/singleflight/">singleflight</a></div><div class="post-share"><div class="social-share" data-image="/img/20220513011040_fc477.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2025/08/14/CSDIY/MyChat/" title="post"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">post</div></div></a><a class="next-post pull-right" href="/2025/08/02/programingLanguage/golang/Slice/" title="Golang Slice、String and Arrary"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Golang Slice、String and Arrary</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2025/07/26/programingLanguage/golang/GC/" title="golang GC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">golang GC</div></div></a><a href="/2025/07/26/programingLanguage/golang/GMP/" title="GMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">GMP</div></div></a><a href="/2025/07/26/programingLanguage/golang/Map/" title="Golang Map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="title">Golang Map</div></div></a><a href="/2025/07/31/programingLanguage/golang/Lock/" title="Lock"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-31</div><div class="title">Lock</div></div></a><a href="/2025/08/02/programingLanguage/golang/Slice/" title="Golang Slice、String and Arrary"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-02</div><div class="title">Golang Slice、String and Arrary</div></div></a><a href="/2025/08/14/CSDIY/MyChat/" title="post"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="title">post</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/20220513011040_fc477.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LiamRyan</div><div class="author-info-description">一个学不会的废物</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuun05"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/iuun05" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客部分功能还未完善，后续会陆陆续续完善，请见谅</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">基础数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-%E5%92%8C-dochan"><span class="toc-number">2.2.</span> <span class="toc-text">Do 和 DoChan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docall"><span class="toc-number">2.3.</span> <span class="toc-text">doCall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forget"><span class="toc-number">2.4.</span> <span class="toc-text">Forget</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/14/CSDIY/MyChat/" title="post">post</a><time datetime="2025-08-14T13:07:15.000Z" title="发表于 2025-08-14 21:07:15">2025-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/programingLanguage/golang/singlefilght/" title="golang 中的 singleflight">golang 中的 singleflight</a><time datetime="2025-08-04T07:20:01.000Z" title="发表于 2025-08-04 15:20:01">2025-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/programingLanguage/golang/Slice/" title="Golang Slice、String and Arrary">Golang Slice、String and Arrary</a><time datetime="2025-08-02T07:15:36.000Z" title="发表于 2025-08-02 15:15:36">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/31/programingLanguage/golang/Lock/" title="Lock">Lock</a><time datetime="2025-07-31T10:02:44.000Z" title="发表于 2025-07-31 18:02:44">2025-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/hexo/asset-img/" title="hexo 图片无法正常显示解决办法">hexo 图片无法正常显示解决办法</a><time datetime="2025-07-26T16:42:16.000Z" title="发表于 2025-07-27 00:42:16">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By LiamRyan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.0.0-b1"></script><script src="/js/main.js?v=5.0.0-b1"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({svg}) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>