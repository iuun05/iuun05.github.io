<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT 6.824 | </title><meta name="author" content="LiamRyan"><meta name="copyright" content="LiamRyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab1 MapReduce mapreduce 是 google 提出的一种分布式模型，用于大规模的数据并行处理，核心思路就是 map 和 reduce 两个阶段，分别对应的是分片处理和汇总聚合。（简单来说就是拆分大问题，合并小问题）。 Papar 这是 MapReduce 的论文 rfeet.qrk，其中主要的思想就是下面这张图 ![[.&#x2F;MIT6_824&#x2F;Pasted image 20250">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.824">
<meta property="og:url" content="http://iuun05.github.io/2025/07/26/CSDIY/MIT6_824/index.html">
<meta property="og:site_name">
<meta property="og:description" content="Lab1 MapReduce mapreduce 是 google 提出的一种分布式模型，用于大规模的数据并行处理，核心思路就是 map 和 reduce 两个阶段，分别对应的是分片处理和汇总聚合。（简单来说就是拆分大问题，合并小问题）。 Papar 这是 MapReduce 的论文 rfeet.qrk，其中主要的思想就是下面这张图 ![[.&#x2F;MIT6_824&#x2F;Pasted image 20250">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://iuun05.github.io/img/20220513011040_fc477.png">
<meta property="article:published_time" content="2025-07-26T13:29:06.000Z">
<meta property="article:modified_time" content="2025-07-26T15:08:24.395Z">
<meta property="article:author" content="LiamRyan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://iuun05.github.io/img/20220513011040_fc477.png"><link rel="shortcut icon" href="/GWdBd10WcAAyRuc.jpg"><link rel="canonical" href="http://iuun05.github.io/2025/07/26/CSDIY/MIT6_824/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.0.0-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT 6.824',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-26 23:08:24'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/20220513011040_fc477.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title=""><img class="site-icon" src="/img/20220513011040_fc477.png" alt="Logo"/><span class="site-name"></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MIT 6.824</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-26T13:29:06.000Z" title="发表于 2025-07-26 21:29:06">2025-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-26T15:08:24.395Z" title="更新于 2025-07-26 23:08:24">2025-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSDIY/">CSDIY</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSDIY/MIT-6-824/">MIT 6.824</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MIT 6.824"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Lab1 MapReduce</h1>
<p>mapreduce 是 google 提出的一种分布式模型，用于大规模的数据并行处理，核心思路就是 map 和 reduce 两个阶段，分别对应的是分片处理和汇总聚合。（<em>简单来说就是拆分大问题，合并小问题</em>）。</p>
<h2 id="papar">Papar</h2>
<p>这是 MapReduce 的论文 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">rfeet.qrk</a>，其中主要的思想就是下面这张图</p>
<p>![[./MIT6_824/Pasted image 20250316225305.png]]</p>
<h2 id="实现方案">实现方案</h2>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf">The design of a practical system for fault-tolerant virtual machines</a></p>
<p>主要的实现部分是在 src/mr中则介绍相关部分</p>
<h3 id="coordinator-go">coordinator.go</h3>
<p>实现流程主要是</p>
<ol>
<li>
<p><strong>MakeCoordinator（）</strong>  对 master 结点进行相关初始化，另外这里我在这了解到 golang 的生命周期以及衍生的逃逸分析问题</p>
</li>
<li>
<p><strong>Register（）</strong> 这部分是接收来自 worker 节点的信息，每当有新的 worker 节点来的时候进行注册，为其分配相关的 ID，方便后面进行任务的申请</p>
</li>
<li>
<p><strong>AssignTask（）</strong> 此函数是接收 worker 的任务请求，需要注意的是此处包含几个问题：</p>
<ol>
<li>首先需要保证节点是在 master 中的，防止后面 timeout 删除后导致的错误</li>
<li>保证 worker 是 Idle 的防止异常申请导致正常的任务被打断</li>
<li>Map 与 Reduce 所需的请求不同，部分内容需要分别进行处理，比如 Map 需要传入文件名称，但是 Reduce 不需要</li>
</ol>
<p>另外，这个函数写完之后也觉得有几个问题，之后有时间进行修改：<br>
4. file，task直接进行切片，但是正常情况下  Files 信息需要进行保留，而且直接切片的效率可能也给更低（未经过验证）</p>
</li>
<li>
<p><strong>CompleteTask（）</strong> 每个 worker 完成任务之后进行报告，方便进行下一次的任务分配。同时也是 Map 任务转为 Reduce 任务的函数节点</p>
</li>
<li>
<p>其他功能函数：</p>
<ol>
<li><strong>HeartBeat（）</strong> 心跳机制，保证 worker 可用</li>
<li><strong>MonitorTasks（）</strong> 检测每个 worker 的状态，当 worker 超时的时候进行标记，然后进行删除</li>
<li><strong>Done（）</strong> 结束标志，lab1 在 mrcoordinator.go 中调用，通过每秒检测返回值来判断是否完成任务</li>
</ol>
</li>
</ol>
<p>另外我学到一个新知识就是 <em>golang 的生命周期</em></p>
<blockquote>
<p>golang的生命周期指的是指：如果函数返回了相关的引用，那么GC不会立刻回收这部分的内存，而是会保留相关引用，因此如果在这里使用 go 启动协程是不会结束的。</p>
</blockquote>
<p>示例代码如下，此段代码不会返回结束，因为 <code>return &amp;c</code> 导致生命周期未结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a Coordinator.</span></span><br><span class="line"><span class="comment">// main/mrcoordinator.go calls this function.</span></span><br><span class="line"><span class="comment">// nReduce is the number of reduce tasks to use.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeCoordinator</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Coordinator &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(files)</span><br><span class="line">	c := Coordinator&#123;</span><br><span class="line">		nMap:     n,</span><br><span class="line">		LeftTask: n,</span><br><span class="line">		files:    files,</span><br><span class="line">		nReduce:  nReduce,</span><br><span class="line">		Workers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Task),</span><br><span class="line">		Tasks:    <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		TaskType: Map,</span><br><span class="line">		Worked:   <span class="number">0</span>,</span><br><span class="line">		done:     <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.nMap &#123;</span><br><span class="line">		c.Tasks = <span class="built_in">append</span>(c.Tasks, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	<span class="keyword">go</span> c.MonitorTasks()</span><br><span class="line"></span><br><span class="line">	c.server()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="worker-go">worker.go</h3>
<p>worker 的实现流程与 <strong>coordinator.go</strong> 的实现流程相互对应，主要是进行 RPC 调用。</p>
<p>相关的实现：</p>
<ol>
<li><strong>Worker()</strong> 这是主要的调用函数，除了 <strong>WorkerRegister（）</strong> 和 <strong>WorkerHeartBeat（）</strong> 函数，其他调用都在死循环中，完成从任务请求，任务执行，到任务结束向 master 汇报一整个流程然后进入到新的循环之中。<strong>WorkerHeartBeat（）</strong> 需要使用协程来运行，<em>同时需要注意，如果 worker 挂掉了，协程需要进行释放，否则会一直进行请求</em></li>
<li><strong>WorkerRegister（）</strong> 无特别需要注意部分</li>
<li><strong>WorkerAssign（）</strong> 无特别需要注意部分</li>
<li><strong>WorkerHeartBeat（）</strong> 需要注意这里需要关注 worker 是否因为其他原因导致被 master 处理掉了，在处理掉的同时进行协程的关闭</li>
<li><strong>WorkerCompleted（）</strong> 无特别需要注意部分</li>
<li>Map 和 Reduce 函数结合论文以及提示中的内容来即可</li>
</ol>
<h1>Lab 2 Key/Value Server</h1>
<p>这是后续的 shard kv 的一个初版，只是实现了简单的 kv 存储系统和一个简单的分布式锁。比较容易实现，主要是一些概念之类的东西。</p>
<h1>Lab 3 Raft</h1>
<p>Raft 是一种用于管理复制日志的共识算法。是基于 <em>(multi-)Paxos</em> ，目的是简化 <em>Paxos</em>，增加可理解性（<em>将共识算法的关键要素分开， leader election, log replication, and safety</em>）以及能适用于真实的系统设计</p>
<h2 id="专业术语">专业术语</h2>
<p>这是我读论文的时候不认识的一些专有名词，顺手记下来几个</p>
<h3 id="non-byzantine-byzantine">non-Byzantine &amp; Byzantine</h3>
<h4 id="问题起源">问题起源</h4>
<p>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。</p>
<p>基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。</p>
<p>困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。</p>
<p><strong>在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商达成一致，从而赢取战斗？</strong></p>
<p>![[Pasted image 20250323143910.png]]</p>
<h4 id="问题实质">问题实质</h4>
<p>寻找到一个方法，使得系统在有错误节点，或者恶意节点的时候保证系统整体的一致性和正确性。<em>（即非信任状态下的共识方法）</em></p>
<p>主要是需要保证以下两个特性</p>
<ul>
<li>一致性：所有非拜占庭的节点（即正确节点）需要有相同的输入（指令），然后给出相同的输出（即同时发起进攻）</li>
<li>正确性：保证所有非拜占庭的节点都能接收到正确的指令。</li>
</ul>
<h4 id="分类">分类</h4>
<h5 id="拜占庭容错系统">拜占庭容错系统</h5>
<p>拜占庭容错系统要解决的正是分布式<strong>系统中存在恶意节点（即拜占庭节点）时，系统的一致性、正确性等问题</strong></p>
<p><strong>假设分布式系统拥有n台节点，并假设整个系统拜占庭节点不超过m台（n ≥ 3m + 1）</strong>，拜占庭容错系统需要满足如下两个条件：</p>
<blockquote>
<p><strong>Note</strong><br>
为什么会是 n ≥ 3m + 1 ？</p>
<p>假设：<br>
1. 总结点数为 n<br>
2. 拜占庭节点数为 m<br>
3. 诚实节点（非拜占庭节点数）为 h，h = n - m</p>
<p>条件：<br>
1）拜占庭节点数必须少于诚实节点：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n - m \geq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> ==&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">n \geq 2m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">m</span></span></span></span><br>
2）允许拜占庭节点存在的情况下的一致性，由于大多数都是使用的投票机制，那么就是要保证诚实节点的数量要占大部分：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>≥</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-m \geq 2m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> , so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>3</mn><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \geq 3m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</blockquote>
<ul>
<li><strong>所有非拜占庭节点使用相同的输入信息，产生同样的结果。</strong> 在区块链系统中，可以理解为，随机数相同、区块算法相同、原账本相同的时候，计算结果相同。</li>
<li><strong>如果输入的信息正确，那么所有非拜占庭节点必须接收这个消息，并计算相应的结果。</strong>  在区块链系统中，可以理解为，非拜占庭节点需要对客户的请求进行计算并生成区块。</li>
</ul>
<p>另外，<strong>拜占庭容错系统需要达成如下两个指标：</strong></p>
<ul>
<li><strong>安全性：</strong> 任何已经完成的请求都不会被更改，它可以在以后请求看到。在区块链系统中，可以理解为，已经生成的账本不可篡改，并且可以被节点随时查看。</li>
<li><strong>活性：</strong> 可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。在区块链系统中，可以理解为，系统需要持续生成区块，为用户记账，这主要靠挖矿的激励机制来保证。</li>
</ul>
<h3 id="lsm-log-structured-merge-tree">LSM（Log Structured Merge Tree）</h3>
<p>是一种使用适用于 NoSQL 的一种储存结构。</p>
<p>LSM树的核心特点是利用顺序写来提高写性能，但因为分层(此处分层是指的分为内存和文件两部分)的设计会稍微降低读性能，但是通过牺牲小部分读性能换来高性能写，使得LSM树成为非常流行的存储结构。</p>
<p>![[./MIT6_824/Pasted image 20250423100626.png]]</p>
<ol>
<li>
<p>Memtable：MemTable是在 <strong><em>内存</em></strong> 中的数据结构，用于保存最近更新的数据，会按照 Key 有序地组织这些数据，LSM树对于具体如何组织有序地组织数据并没有明确的数据结构定义，例如Hbase使跳跃表来保证内存中key的有序。</p>
</li>
<li>
<p>Immutable Memtable （Immutable ： 不可改变的）: 当 MemTable 达到一定大小后，会转化成Immutable MemTable。Immutable MemTable是将转MemTable变为SSTable的一种<strong>中间状态</strong>。写操作由新的 MemTable 处理，在转存过程中不阻塞数据更新操作。</p>
</li>
<li>
<p>SSTable（Sorted String Table）: <strong><em>有序键值对</em></strong> 集合，是LSM树组在 <strong><em>磁盘</em></strong> 中的数据结构。为了加快SSTable的读取，可以通过建立key的索引以及布隆过滤器来加快key的查找。</p>
</li>
</ol>
<blockquote>
<p>布隆过滤器：<strong>布隆过滤器可以用于检索一个元素是否在一个集合中</strong>。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p>
<p>但是存在有一些问题，由于 LSM 存储都是日志化的，会记录所有的变化，因此会存在有 <strong>数据冗余</strong> 的情况，只有最新的 key 的数据才是有效的（不同于 innodb 这种 B+ tree 的引擎，B+ tree 都是进行原地修改，因此不存在 数据冗余 的情况 ） ————  日志压缩 （log compact），论文 第七小节并且读取的时候需要从后往前进行查询 ———— 布隆过滤器</p>
</blockquote>
<h4 id="log-compact">Log Compact</h4>
<p>日志压缩主要是围绕这三个部分:</p>
<blockquote>
<p>1）读放大:读取数据时实际读取的数据量大于真正的数据量。例如在LSM树中需要先在MemTable查看当前key是否存在，不存在继续从SSTable中寻找。</p>
<p>2）写放大:写入数据时实际写入的数据量大于真正的数据量。例如在LSM树中写入时可能触发Compact操作，导致实际写入的数据量远大于该key的数据量。</p>
<p>3）空间放大:数据实际占用的磁盘空间比数据的真正大小更多。上面提到的冗余存储，对于一个key来说，只有最新的那条记录是有效的，而之前的记录都是可以被清理回收的。</p>
</blockquote>
<h5 id="size-tiered-compaction">size-tiered compaction</h5>
<p>主要核心是将 <strong>多个相同大小的 SSTable 文件合并为一个更大的文件，然后放入到下一层中</strong>，逐步形成一个层次结构。</p>
<blockquote>
<p>每层限制SSTable为N，当每层SSTable达到N后，则触发Compact操作合并这些SSTable，并将合并后的结果写入到下一层成为一个更大的sstable。</p>
</blockquote>
<p>但是这样会引发空间放大的问题，因为 <strong>key 的旧版本会在多个 SSTable 中共存一段时间</strong>，直到被合并清除。</p>
<h5 id="leveled-compaction">leveled compaction</h5>
<p><strong>leveled策略也是采用分层的思想，每一层限制总文件的大小。</strong></p>
<p>但是呢，<em>leveled会将每一层切分成多个大小相近的SSTable。这些SSTable是这一层是 <strong>全局有序</strong> 的，意味着一个key在每一层至多只有1条记录，不存在冗余记录。</em></p>
<p>合并方式：如图，L1中至少选择一个文件，然后把它和跟 L2 有交集的部分进行融合，然后将文件放置在 L2 中。 L3 与 L4 重复类似的过程。并且这是可以进行 <strong>并行化的。</strong><br>
![[./MIT6_824/Pasted image 20250423104426.png]]</p>
<h2 id="共识算法特点">共识算法特点</h2>
<ol>
<li>
<p><strong>它们在所有非拜占庭条件下确保安全</strong>（永远不会返回错误的结果），包括网络延迟、分区、数据包丢失、重复和重排序。</p>
</li>
<li>
<p><strong>只要大多数服务器正常运行并能相互以及与客户端通信，它们就完全可用</strong>。因此，一个典型的五服务器集群可以容忍任何两个服务器的故障。服务器假定通过停止来失败；它们可以从稳定存储上的状态恢复，并重新加入集群。</p>
</li>
</ol>
<h2 id="raft">Raft</h2>
<h3 id="特点">特点</h3>
<ol>
<li>强领导者：Raft 采用了比其他共识算法更强的领导形式。例如，日志条目仅从领导者流向其他服务器。这简化了复制日志的管理，并使 Raft 更易于理解。</li>
<li>领导者选举：Raft 使用随机计时器来选举领导者。这只会在任何共识算法所需的心跳基础上添加少量机制，同时还能简单快速地解决冲突。</li>
<li>成员变更：Raft 用于更改集群中服务器集的机制采用一种新的联合共识方法，其中两种不同配置的多数在转换期间重叠。这允许集群在配置更改期间继续正常运行。</li>
</ol>
<h3 id="流程">流程</h3>
<p>![[./MIT6_824/Pasted image 20250325155046.png]]</p>
<p><code>Follower</code>： 默认状态且为被动状态，其中只有<code>Follower</code>会接收来自客户端的请求，但是自己不会主动发送请求，只是对<code>Candidate &amp;&amp; Leader</code>的请求做出响应。</p>
<p><code>Leader</code>: 处理所有客户端请求（如果客户端联系<code>Follower</code>，<code>Follower</code>会将它重定向到<code>Leader</code>）</p>
<p><code>Cadidate</code>：<code>Leader</code> 备选</p>
<h2 id="系统架构">系统架构</h2>
<p>论文中相关的架构如下，简洁的描述了 raft 一致性算法的规则。本质上是对状态机</p>
<p>![[./MIT6_824/Pasted image 20250325153700.png]]</p>
<h3 id="基本原则">基本原则</h3>
<h3 id="安全性论证">安全性论证</h3>
<p>首先证明方法是通过<em>反证法</em>进行证明的。</p>
<p>![[./MIT6_824/Pasted image 20250327120342.png]]</p>
<p>——对图的理解如下：<br>
1. 当 S1 commit一个日志条目之后，那么一定是有大部分的 server 接收到该日志条目<br>
2. 并且，如果 S5 想要成为 leader 那么，一定需要大部分的 follower 投票给 S5</p>
<p>但是，正是如此，那么一定会有一个 server 在图中为 S3 会接收到 T commit 的日志条目，并且给 S5 投票，那么就不符合我们之前的选举规则。投票给了比自己更旧的 cadidate</p>
<p>论文假设了两个 <code>leader</code>, T 和 U，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>r</mi><msub><mi>m</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">term_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &lt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>r</mi><msub><mi>m</mi><mi>U</mi></msub></mrow><annotation encoding="application/x-tex">term_U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><msub><mi>r</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">leader_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在任期之间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">commit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 了一个日志条目，图中显示的是 <code>AE</code> 。并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><msub><mi>r</mi><mi>U</mi></msub></mrow><annotation encoding="application/x-tex">leader_U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是没有储存该条目的。</p>
<p><strong>论证步骤如下：</strong></p>
<ol>
<li>
<p>在leaderU选举时，一定没有那个被提交的日志条目（<code>Leader</code>从来不会删除或者覆盖日志条目）。——这是基于假设给定的，并且只有当 <code>leader</code> 与 <code>follower</code> 出现任期不匹配的时候才会删除不匹配的日志，<code>leader</code> 是不会删除日志或者覆盖日志条目的</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>e</mi><msub><mi>r</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">leader_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在集群的大多数<code>Server</code>上复制了这个条目。因此，至少有一个<code>Server</code>（投票者）既接收了来自leaderT的日志条目，又投票给<code>leader_U</code>，如<code>图-9</code>所示。这个投票者是产生矛盾的关键。</p>
</li>
<li>
<p>投票者必须在给 <code>leader_U</code> 投票之前接收来自<code>leader_T</code>的已提交日志条目；否则它会拒绝来自<code>leader_T</code> 的<code>AppendEntries</code>请求（它的当前任期会比T要大）。——这里说明的是如果没有在 T 的任期加入 <code>commit</code> 的日志的话，那么之后就会拒绝相关的 rpc 请求</p>
</li>
<li>
<p>投票者会在它给 <code>leader_U</code> 投票时存储那个条目，因为任何中间的 <code>Leader</code> 都保有该条目（基于假设），<code>Leader</code>从来不会移除这个条目，并且<code>Follower</code>也只会在和<code>Leader</code>冲突时才会移除日志条目。</p>
</li>
<li>
<p>投票者给<code>leader_U</code> 投票了，所以 <code>leader_U</code> 的日志必须和投票者的一样新。这就导致了一个矛盾。——我理解的是，对于每一个在 T 崩溃周的中间的 <code>leader</code> 都要保存 T 所 <code>commit</code> 的日志条目，但是 leader 只有在冲突的时候才会删除日志条目，否则则会一直保存这已有的数据。但是呢，根据 voter 规则， voter 只会投给和自己相近的，或者更新的，否则就会拒绝投票。 <em>根据假设，Leader_U 是不包含相关条目的，因此会产生矛盾</em>。</p>
</li>
<li>
<p>首先，如果投票者和<code>leader_U</code> 最后一条日志条目的任期编号相同，那么 <code>leader_U</code> 的日志一定和投票者的一样长，因此它的日志包含全部投票者的日志条目。这是矛盾的，因为在假设中投票者和 <code>leader_U</code> 包含的已提交条目是不同的。</p>
</li>
<li>
<p>除此之外，<code>leader_U</code> 的最后一条日志的任期编号一定比投票者的大。另外，它也比T要大，因为投票者的最后一条日志条目的任期编号最小也要是 T（它包含了所有任期T提交的日志条目）。创建<code>leader_U</code> 最后一条日志条目的上一任<code>Leader</code>必须包含已经提交的日志条目（基于假设）。那么，根据日志匹配原则（Log Matching），<code>leader_U</code>也一定包含那条提交的日志条目，这也是矛盾的。——  其实就是说 leader_U 肯定不是凭空产生的，他也是基于之前的 follower 而来，因此更具 Log Matching Rules ，那么 leader_U 一定是包含 leader_T 的所 commit 的所有信息</p>
</li>
<li>
<p>这时就完成了矛盾推导。因此，所有比任期T大的<code>Leader</code>一定包含所有在任期T提交的日志条目。</p>
</li>
<li>
<p>日志匹配原则（Log Matching）保证了未来的<code>Leader</code>也会包含被间接提交的日志条目，就像<code>图-8</code>中(d)时刻索引为2的条目。<br>
![[./MIT6_824/Pasted image 20250327120819.png]]</p>
</li>
</ol>
<h2 id="实现">实现</h2>
<h3 id="lab3a-leader-election">lab3A leader election</h3>
<p>先贴个结果，lab 3B 报的错是 fail reach 感觉是并发测试开多了导致的，后续也没有太大的影响也就没管了。<br>
![[./MIT6_824/Pasted image 20250517192856.png]]</p>
<h4 id="原理">原理</h4>
<h5 id="初始状态">初始状态</h5>
<p>初始化状态每一个 <code>server</code> 都是 <code>follower</code>，等待超时。</p>
<h5 id="选举状态">选举状态</h5>
<p>当某些服务器在初始状态超时之后就会进入到 <code>cadidate</code> 状态</p>
<p><strong>成为 cadidate 需要注意的是</strong>：</p>
<ol>
<li><strong>任期必须先自加 1</strong></li>
<li>向其他的服务器节点发送请求投票的 RPCs 来拉票，直到以下事件发生才能停止。
<ol>
<li>自己赢得选举，（先来先到，符合日志匹配原则，成为 leader 之后立刻发送心跳信息阻止选举，但是会比较任期，任期大的才有资格留下来）</li>
<li>其他服务器成为 leader</li>
<li>一段时间之后没有任何一个获胜的人（等待  cadidate 超时，重新开始选举）</li>
</ol>
</li>
</ol>
<blockquote>
<p>实现过程中需要注意的相关事项或者问题大部分都可以在 <a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft :: Jon Gjengset</a>中找到答案，十分推荐去阅读一遍。</p>
</blockquote>
<h6 id="任期或者状态的更新">任期或者状态的更新</h6>
<ol>
<li>
<p>如果在投票的过程中，给其他的 <code>server</code> 发送相关 RPC 请求（<em>RequestVote</em> or <em>AppendEntries</em> ）的时候需要对 <code>reply</code> 所返回的任期进行一个判断，<em>如果 cadidate 的任期低于 follower， 或者说有其他比该任期高的 server</em>  需要将 <code>cadidate</code> 或者 <code>leader</code> 重置为 <code>follower</code>，并且需要更新时间。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if reply term is higher than currentTerm, convert to Follower</span></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; currentTerm &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;[term_error] vote RPC for peer %d: reply term %d higher than currentTerm %d, converting to Follower\n&quot;</span>, peer, reply.Term, currentTerm)</span><br><span class="line">    rf.currentTerm = reply.Term</span><br><span class="line">    rf.lastPing = time.Now()</span><br><span class="line">    rf.identity = Follower</span><br><span class="line">    rf.isleader = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果出现任期比当前 leader 大的那么需要立刻转变为 follower，因为此时他已经是过时的 leader，数据不是最新的（可能经历过网络分区后重新加入集群）现在不具备向其他的 server 发送心跳的权力。</p>
</li>
<li>
<p>如果出现了 leader（任期最新，数据最新），当前所有的 cadidate 那么需要立刻停止选举。</p>
</li>
</ol>
<p>2，3 情况的实现方法相似，我是通过 <code>Context</code> 包来控制 Goroutine 的。贴一个心跳的伪代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    heartbeatCtx, heartbeatCancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> heartbeatCancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    <span class="keyword">if</span> rf.identity != Leader &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    RPCRequest()</span><br><span class="line">    <span class="keyword">if</span> condition &#123;</span><br><span class="line">        ...</span><br><span class="line">        heartbeatCancel()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="时间的更新">时间的更新</h6>
<p>时间的更新关系到选举的进行，这是十分重要的，如果时间更新没注意十分容易出现活锁（即 <code>leader</code>快速变化）的情况，具体的更新情况有三种（来自 [stduents guide](<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft :: Jon Gjengset</a>)）</p>
<ul>
<li>从当前领导者收到 <code>AppendEntries</code> RPC（即如果 <code>AppendEntries</code> 参数中的任期已过时，您不应重置计时器）</li>
<li>正在启动选举</li>
<li>授予另一个对等节点投票权</li>
</ul>
<h6 id="vote-的变化">Vote 的变化</h6>
<p>起初我在写的时候一直在想，如何重置 <code>vote</code> 的变化，是不是每个新的任期出现就需要更新一遍初始状态，但是其实实现方法很简单，只需要和任期相互绑定即可，实现方法就是对参数中的任期进行判断。</p>
<p>如果 <code>args</code> 中的任期大于现在 raft 节点的任期，那么就说明此时又开始了一轮新的选举，那么只需要简单的重置一下此时的 <code>term</code> 和 <code>vote</code>，那么就可以很简单的实现了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">    reply.Term = rf.CurrentTerm</span><br><span class="line">    reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start a new election, reset votedFor and votes</span></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">    rf.CurrentTerm = args.Term</span><br><span class="line">    reply.Term = rf.CurrentTerm</span><br><span class="line">    rf.identity = Follower</span><br><span class="line">    rf.isleader = <span class="literal">false</span></span><br><span class="line">    rf.VoteFor = <span class="number">-1</span></span><br><span class="line">    rf.votes = <span class="number">0</span></span><br><span class="line">    rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="心跳时间选择">心跳时间选择</h6>
<p>感觉很玄学，有可能会影响测试，这是我最后的心跳时间选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// election</span></span><br><span class="line">ms := <span class="number">150</span> + (rand.Int63() % <span class="number">450</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeartBeat</span></span><br><span class="line">ms := <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="lab3b-log">lab3B log</h3>
<h4 id="日志的发送与快速回退-appendentries">日志的发送与快速回退 AppendEntries</h4>
<p>之前写 3A 的时候把 <code>heartbeat</code> 单独写出来的，后面发现不合理，重新改了一版，将 <code>heartbeat</code> 和 <code>append_entries</code> 合并在一起了（正确方式就是应该合并的）</p>
<p>另外，在 <code>append_entries</code> 中，加入了一些优化机制，主要是参考的论文中的这么一段文字：</p>
<blockquote>
<p>If desired, the protocol can be optimized to reduce the number of rejected AppendEntries RPCs by having the follower include the term of the conflicting entry and the first index it stores for that term when rejecting an AppendEntries request; with this information, the leader can decrement <code>nextIndex</code> to bypass all conflicting entries in that term, requiring only one AppendEntries RPC per term with conflicting entries instead of one RPC per entry, though in practice this optimization may be unnecessary due to the infrequency of failures and the unlikely occurrence of many inconsistent entries.</p>
</blockquote>
<p>参考这个思想在论文的基础上加入了两个变量，来保证 leader 能够知道 follower 需要哪一段日志，相关结构体定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Term    <span class="type">int</span>  <span class="comment">// currentTerm, for leader to update itself</span></span><br><span class="line">    Success <span class="type">bool</span> <span class="comment">// true if follower contained entry matching prevLogIndex and prevLogTerm</span></span><br><span class="line">    ConflictTerm  <span class="type">int</span> <span class="comment">// term of conflicting entry</span></span><br><span class="line">    ConflictIndex <span class="type">int</span> <span class="comment">// index of conflicting entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要注意的情况如下：</p>
<ul>
<li>如果 follower 长度不足，那么直接返回 follower 的 log 长度即可，然后 ConfilctTerm 返回 -1</li>
<li>如果 follower 长度足够，那么返回 <code>rf.log[args.PrevLogIndex].Term</code>， 然后删除该任期的所有 log ，但是大于 follower 的 commitIndex，我认为这样可以减少发送一些 log</li>
</ul>
<p>以上的优化机制是怎么运行的呢？简单的来举个例子：</p>
<table>
<thead>
<tr>
<th>server/loglen</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>S1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>S2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>S3</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>如果 首先 S3 为 leader ， 然后在 2 的时候被 partition。</p>
<p>然后 S1 成为 leader， 和 S2 相互通信，如果此时 S3 rejoin，那么就会删除到 partition 之前的状态，即</p>
<table>
<thead>
<tr>
<th>server/loglen</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>S1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>S2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>S3</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">    rf.matchIndex[peer] = max(args.PrevLogIndex+<span class="built_in">len</span>(entries), rf.matchIndex[peer])</span><br><span class="line">    <span class="keyword">if</span> rf.nextIndex[peer] != rf.matchIndex[peer]+<span class="number">1</span> &#123;</span><br><span class="line">        DPrintf(<span class="string">&quot;[append_success] %v -&gt; %v, nextIndex %v, matchIndex %v, commitIndex %v\n&quot;</span>, rf.me, peer, rf.nextIndex[peer], rf.matchIndex[peer], rf.commitIndex)</span><br><span class="line">    &#125;</span><br><span class="line">    rf.nextIndex[peer] = rf.matchIndex[peer] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> reply.ConflictTerm != <span class="number">-1</span> &#123;</span><br><span class="line">        index := <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i := reply.ConflictIndex - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            <span class="keyword">if</span> rf.Log[i].Term == reply.ConflictTerm &#123;</span><br><span class="line">                index = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span> &#123;</span><br><span class="line">            rf.nextIndex[peer] = reply.ConflictIndex</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rf.nextIndex[peer] = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.nextIndex[peer] = reply.ConflictIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提交日志-commit">提交日志 Commit</h4>
<p>为了加快 commit 速度，从当前 commitIndex 判断到 log 的长度为止，然后是额外开启一个 goroutine 进行判断，而不是串行，防止日志过长导致 commitIndex 迟迟不更新而拖延 apply 的运行</p>
<h4 id="应用日志-apply">应用日志 Apply</h4>
<p>这里有个坑就是要防止 channel 长时间持有锁，主要情况就是，默认情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。（<strong>无缓冲 channel 的特点</strong>）</p>
<blockquote>
<p>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到channel中。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>apply 是一个 condition lock，好像是在 student guide 里面里面有提到，这个锁和互斥锁的最大区别就是这个锁是包含一把锁的，在你初始化的时候就知道了，然后最大的问题应该就是使用个锁的 Wait() 时候要提前持有互斥锁，并且在执行 Wait() 的时候它会自动的释放锁，即</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition &#123;</span><br><span class="line">    rf.applyCond.Wait()</span><br><span class="line">    <span class="comment">// 如果运行在这个时候，锁是被自动释放掉了，不需要你再度释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> apply() &#123;</span><br><span class="line">	applyMsgs := <span class="built_in">make</span>([]raftapi.ApplyMsg, MAXBUFFERSIZE)</span><br><span class="line">	<span class="comment">// producer</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">10</span> * time.Millisecond):</span><br><span class="line">			<span class="keyword">case</span> &lt;-rf.commitCh:</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rf.mu.Lock()</span><br><span class="line">			logLen := rf.getLogLen()</span><br><span class="line">			<span class="keyword">for</span> applyIndex := rf.lastApplied + <span class="number">1</span>; applyIndex &lt; logLen &amp;&amp; applyIndex &lt;= rf.commitIndex &amp;&amp; applyIndex &gt; rf.LastIncludedIndex &amp;&amp; applyIndex-rf.lastApplied &lt; MAXBUFFERSIZE; applyIndex++ &#123;</span><br><span class="line">				command := rf.getLogCommand(applyIndex)</span><br><span class="line">				msg := raftapi.ApplyMsg&#123;</span><br><span class="line">					CommandValid:  <span class="literal">true</span>,</span><br><span class="line">					Command:       command,</span><br><span class="line">					CommandIndex:  applyIndex,</span><br><span class="line">					SnapshotValid: <span class="literal">false</span>,</span><br><span class="line">				&#125;</span><br><span class="line">				applyMsgs[applyIndex%MAXBUFFERSIZE] = msg</span><br><span class="line">			&#125;</span><br><span class="line">			rf.applyCond.Broadcast()</span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(rf.applyCh)</span><br><span class="line">		<span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">			rf.mu.Lock()</span><br><span class="line">			<span class="keyword">for</span> rf.lastApplied &gt;= rf.commitIndex &amp;&amp; <span class="built_in">len</span>(rf.snapshotQueue) == <span class="number">0</span> &amp;&amp; !rf.killed() &#123;</span><br><span class="line">				rf.applyCond.Wait()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 优先处理 snapshot</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(rf.snapshotQueue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				snapshot := rf.snapshotQueue[<span class="built_in">len</span>(rf.snapshotQueue)<span class="number">-1</span>]</span><br><span class="line">				<span class="comment">// rf.snapshotQueue = nil</span></span><br><span class="line">				rf.snapshotQueue = rf.snapshotQueue[:<span class="number">0</span>]</span><br><span class="line">				rf.lastApplied = snapshot.SnapshotIndex</span><br><span class="line">				DPrintf(<span class="string">&quot;[apply_snapshot] %v / %v -&gt; lastapplied %v , lastIncluded %v&quot;</span>, rf.me, rf.commitIndex, rf.lastApplied, rf.LastIncludedIndex)</span><br><span class="line">				rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">				rf.applyCh &lt;- snapshot</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理 log apply</span></span><br><span class="line">			nextIndex := rf.lastApplied + <span class="number">1</span></span><br><span class="line">			msg := applyMsgs[nextIndex%MAXBUFFERSIZE]</span><br><span class="line">			<span class="keyword">if</span> msg.CommandValid &amp;&amp; msg.CommandIndex == nextIndex &#123;</span><br><span class="line">				rf.lastApplied = nextIndex</span><br><span class="line">				DPrintf(<span class="string">&quot;[apply_msg] %v / %v -&gt; index %v (%v), lastIncluded %v&quot;</span>, rf.me, rf.commitIndex, nextIndex, msg.CommandIndex, rf.LastIncludedIndex)</span><br><span class="line">				rf.mu.Unlock()</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> rf.applyCh &lt;- msg:</span><br><span class="line">				<span class="keyword">case</span> &lt;-rf.killedCh:</span><br><span class="line">					DPrintf(<span class="string">&quot;%v close channel&quot;</span>, rf.me)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lab-3c-persist">lab 3C Persist</h3>
<p>本次测试存在 unreliable network，这一部分的主要内容我认为应该是处理 丢包，乱序，过时问题。</p>
<p><code>persist</code> 和 <code>readPersist</code> 函数主要是参考案例即可，然后注意编码时需要进行大写，然后在每次修改<code>rf.CurrentTerm</code>，<code>rf.VoteFor</code> ，<code>rf.Log</code>的时候持久化即可，难度不大。</p>
<h4 id="丢包问题">丢包问题</h4>
<p>这个问题这是最简单的，只需要重新发送即可，比如说（其中不确定 select 是否有效，能跑就没动了）：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> !rf.sendRequestVote(peer, &amp;args, &amp;reply) &amp;&amp; !rf.killed() &#123;</span><br><span class="line">     <span class="comment">//  我不知道这个 select 是否有用</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延迟问题-乱序问题">延迟问题（乱序问题）</h4>
<p>延迟问题有两个部分，分别是延迟接收和发送。也就是说需要在 leader 和 follower 处同时进行处理来避免这个问题。</p>
<ol>
<li><strong>延迟发送相同任期的数据</strong>：这一部分需要对 <code>Log</code> 进行一个检查，检查发送的  Log 是否已经包含了这部分，如果包含有这部分，那么就不应该修改 Log，举例来说：</li>
</ol>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>S1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>现在是最初的 Log，然后发送了一个 entries 任期为 3，但是由于网络问题，导致这个网络包一直还未到达。</p>
<p>然后现在，又发送了三个 entries，任期依然为 3，那么就会很顺利的加入到 Log 中，日志变化如下</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>S1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>但是现在问题来了，那一个任期为 3 的 entries 此时也到了，你会发现他会很轻松的到达添加日志的地方，<strong>如果你没有做相关的防范</strong>，此时就会发生一个问题，你会发现日志会在 6 之后被截断</p>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>S1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>解决方法也很简单，那就是从 args 中的 pervLogIndex 开始检查，存在则不加入，不存在则加入</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. Append new entries to the log</span></span><br><span class="line"><span class="comment">// After ensuring no conflicts, we append the new entries from the leader&#x27;s log to the follower&#x27;s log.</span></span><br><span class="line">newIndex, i := args.PrevLogIndex+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(args.Entries); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> newIndex+i &gt;= rf.getLogLen() || rf.getLogTerm(newIndex+i) != args.Entries[i].Term &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args.Entries) &#123;</span><br><span class="line">    <span class="comment">// 3. delete entries from log if an existing entry conflicts with new ones</span></span><br><span class="line">    rf.Log = <span class="built_in">append</span>(rf.Log[:newIndex+i-rf.LastIncludedIndex<span class="number">-1</span>], args.Entries[i:]...)</span><br><span class="line">    rf.persist()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. update commitIndex, if leader&#x27;s commitIndex is greater than follower&#x27;s commitIndex, update follower&#x27;s commitIndex</span></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">    prev_commitIndex := rf.commitIndex</span><br><span class="line">    rf.commitIndex = min(args.LeaderCommit, rf.getLogLen()<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> rf.commitIndex != args.LeaderCommit &#123;</span><br><span class="line">        DPrintf(<span class="string">&quot;[append_commit] %v -&gt; %v (t%v, id %v), entries %v, commitIndex %v / %v\n&quot;</span>, args.LeaderId, rf.me, args.Term, rf.identity, <span class="built_in">len</span>(args.Entries), rf.commitIndex, prev_commitIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reply.Success = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>延迟发送不同任期的数据</strong>：这一部分包括两种情况，一种是被网络分区之后重新加入到原来的网络分区，这种论文中有做处理，就不做说明了。然后另外的情况就是说网络分区中重新发生选举，任期增加，但是 Leader 不变。（其实也不是什么大问题）</li>
</ol>
<h4 id="数据损坏问题">数据损坏问题</h4>
<p>在 reliable network 中，只要相关的 rpc 请求返回 true，那么数据就是正常的，但是实际测试中出现了这样的一个包，也就是说，他正常的请求到了rpc，但是确出现了 term 为 0 的情况，有时会引起莫名其妙的 bug。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reply &#123;</span><br><span class="line">    term :<span class="number">0</span></span><br><span class="line">    success: <span class="literal">false</span></span><br><span class="line">    conflictIndex: <span class="number">1</span></span><br><span class="line">    conflictTerm: <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法就是直接丢弃这部分数据即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term != rf.CurrentTerm || reply.Term == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="坑-error">坑（error）</h4>
<ol>
<li>failed to reach agreement</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal: one(8778102686503907240) failed to reach agreement</span><br></pre></td></tr></table></figure>
<p>我猜测应该是选举超时选的太小了，选举占用大量时间，调大选举时间后问题明显缓解。</p>
<ol start="2">
<li>这个问题一般都是 nextIndex 和 matchIndex 没有正确更新导致的，所以一般都要去看 nextIndex， matchIndex 的更新方式是否正确，需要认真检查 append 部分</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: index out of range [88] with length 1 </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>apply error，我出现这个问题是由于 goroutine 问题，因为 persist 并不是真正的结束 raft 实体，而是将所有的数据保存到 rf.persister 实体中，然后重新加载，但是这样原本阻塞的的 channel 还在运行，还在继续发送，也就是说这样会提前的发送 readpersist 之前的 commitIndex</li>
</ol>
<p>log中会出现类似的 ,这就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[commit].... commitIndex 11</span><br><span class="line">[readpersist] ..... </span><br><span class="line">// 但是这里实际应该是从 1 开始</span><br><span class="line">[apply] 11</span><br></pre></td></tr></table></figure>
<h4 id="todo">todo</h4>
<p>测试还有 bug ，log 如下，查不动了，先这样留着做彩蛋。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">2025/04/22 12:03:52 [election] 4 becomes Leader with 3 votes, term: 23, log length 11</span><br><span class="line">2025/04/22 12:03:52 [start] 4 index 11, term 23, command 867928842208374459</span><br><span class="line">2025/04/22 12:03:52 [append_success] 4 -&gt; 3, nextIndex 10, matchIndex 11, commitIndex 0</span><br><span class="line">2025/04/22 12:03:52 [append_success] 4 -&gt; 2, nextIndex 10, matchIndex 11, commitIndex 0</span><br><span class="line">2025/04/22 12:03:52 [commit] 4 -&gt; index 11, log[N].Term 23, currentTerm 23, commitIndex 11, command &#123;867928842208374459 23 false&#125;</span><br><span class="line">2025/04/22 12:03:52 [apply] 4 / 11 -&gt; index 1 / 12, command 4052737179978994964, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 4 / 11 -&gt; index 2 / 12, command 633407934433877521, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 4 / 11 -&gt; index 3 / 12, command 3503516105229632134, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 4 / 11 -&gt; index 4 / 12, command 7546022265086759426, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 4 / 11 -&gt; index 5 / 12, command 2892773973269466003, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 1 / 12, command 4052737179978994964, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 2 / 12, command 633407934433877521, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 3 / 12, command 3503516105229632134, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 4 / 12, command 7546022265086759426, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 5 / 12, command 2892773973269466003, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 6 / 12, command 573625300185315643, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 7 / 12, command 8524430882984323996, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 8 / 12, command 1555779226060489955, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 9 / 12, command 3075377638808233825, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 10 / 12, command 6415635232418777474, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [apply] 2 / 11 -&gt; index 11 / 12, command 867928842208374459, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;]</span><br><span class="line">2025/04/22 12:03:52 [readpersist] 4 -&gt; term 23, votefor 4, log [&#123;&lt;nil&gt; 0 true&#125; &#123;4052737179978994964 1 false&#125; &#123;633407934433877521 3 false&#125; &#123;3503516105229632134 5 false&#125; &#123;7546022265086759426 6 false&#125; &#123;2892773973269466003 9 false&#125; &#123;573625300185315643 10 false&#125; &#123;8524430882984323996 15 false&#125; &#123;1555779226060489955 16 false&#125; &#123;3075377638808233825 17 false&#125; &#123;6415635232418777474 18 false&#125; &#123;867928842208374459 23 false&#125;], commitIndex 0, applyIndex 0</span><br><span class="line">info: wrote visualization to /tmp/porcupine-3674006959.html</span><br><span class="line">2025/04/22 12:03:52 apply error: server 4 apply out of order 5</span><br></pre></td></tr></table></figure>
<p>至于为什么出现这个问题，我猜测大概是因为 <code>rf.applyCh</code> 的问题，为什么？<br>
看下面日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2025/05/15 23:19:41 [apply_msg] 2 / 65 -&gt; index 41 (41), lastIncluded -1</span><br><span class="line">2025/05/15 23:19:41 [apply_msg] 2 / 65 -&gt; index 42 (42), lastIncluded -</span><br><span class="line">2025/05/15 23:19:41 server 2 apply order 41, command 3329250121487263777</span><br><span class="line">2025/05/15 23:19:41 server 2 apply order 42, command 1348157186345728959</span><br><span class="line">2025/05/15 23:19:41 [apply_msg] 2 / 65 -&gt; index 43 (43), lastIncluded -1</span><br><span class="line">2025/05/15 23:19:41 [apply_msg] 2 / 65 -&gt; index 44 (44), lastIncluded -1</span><br><span class="line">2025/05/15 23:19:41 [readpersist] 2 -&gt; term 72, votefor 2, lastIncludedIndex -1 / commitIndex 0 / lastApplied 0, lastIncludedTerm -1, log 66</span><br><span class="line">2025/05/15 23:19:41 server 2 apply order 43, command 4634105287464626619</span><br><span class="line">info: wrote visualization to /tmp/porcupine-2290684499.html</span><br><span class="line">2025/05/15 23:19:41 apply error: server 2 apply out of order 43</span><br></pre></td></tr></table></figure>
<p>你发现在 readpersist 之后，server 端为什么又接收到43了，按照正常顺序来说，在 readpersist 之后，应该是从 1 开始了。我猜测应该是阻塞导致的，至于解决办法，我是去修改了测试代码，不知道是不是 bug，修改之后就美美的过 1w 次了。（给课题组发了邮件也没回我，估计被当垃圾邮件处理了）</p>
<h3 id="lab4d-snapshot">lab4D snapshot</h3>
<p>Snapshot 最大的问题大概就是去重构了，由于之前没有意识，没对 log 预留接口，导致再 snapshot 之后日志截断就歇菜了，不过处理方法非常简单，只需要将所有 log 操作进行封装即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLogLen() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(rf.Log) + rf.LastIncludedIndex + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLogTerm(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt;= rf.LastIncludedIndex &#123;</span><br><span class="line">        <span class="keyword">return</span> rf.LastIncludedTerm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rf.Log[rf.getLogIndex(index)].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLogCommand(index <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> rf.Log[rf.getLogIndex(index)].Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> getLogIndex(index <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index - rf.LastIncludedIndex - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 snapshot 的操作就是增加两个参数，一个是 lastIncludedIndex, lastIncludedTerm. 需要对这两个进行持久化。然后读取</p>
<p>然后在发送心跳的时候将 lastIncludedIndex 与 nextIndex 进行判断，小于那么就直接发送 InstallSnapshot， 反之则不处理</p>
<p>InstallSnapshot 直接按照论文写即可，然后再结合 hint，丢弃 offset， done。实现起来非常简单。</p>
<p>需要注意的是，你要考虑这个情况，当你 installsnapshot 之后，需要向上层发送消息，那么你在发送 channel 的时候需要丢弃一些数据，回退一些数据。</p>
<p>比如说，现在已经 installsnapshot 19， 那么你向上传递的数据就必须要大于 19。</p>
<h2 id="总结">总结</h2>
<p>简单来说就是实现了 Raft 的四个过程，我写了接近一个月，写的很崩溃，查问题几乎耗了我半个多月的时间，但是不得不说这对我的代码能力提升很大，以及解决问题的能力也有不少提高，感觉有挑战才会有收获。</p>
<h1>lab4 Fault-tolerant Key Value Service</h1>
<p>整体结构如下，另外可能需要修改一下 raft 中的 apply 部分，保证能及时的关闭 applyCh，然后让 rsm 部分及时的响应。<br>
![[./MIT6_824/Pasted image 20250510133614.png]]</p>
<h2 id="4a-replicated-state-machine-rsm">4A replicated state machine (RSM)</h2>
<p>优化 raft 之前。（Raft 做了两版，这是第二版）<br>
![[./MIT6_824/Pasted image 20250510160702.png]]</p>
<p>这是优化之后的，出现了一点问题，不确定是不是当时测试 CPU 跑满的问题导致一些函数来不及调度导致的。我寻思问题也不算大，我就不管了。这是两次测试之后的。<br>
![[./MIT6_824/Pasted image 20250519190753.png]]<br>
![[./MIT6_824/Pasted image 20250521115112.png]]</p>
<p>代码量在优化之后其实很少，但是之前的 raft 有点问题，在 kill 之后没有关闭 rf.applych 在 apply 结束关闭就行。需要注意关闭 channel 的原则：</p>
<ol>
<li>只有发送方（Sender）才能关闭 channel</li>
<li>关闭的 channel 只能关闭一次</li>
<li>关闭 channel 是通知机制，不是必需操作</li>
<li>当有多个接收者时，更适合使用关闭通道来广播退出</li>
<li>通道一般在创建者处关闭</li>
</ol>
<p>起初，我的想法是维护一个 channel map，定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> message <span class="keyword">struct</span> &#123;</span><br><span class="line">    access   <span class="type">bool</span></span><br><span class="line">    response any</span><br><span class="line">    err      rpc.Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pendingOp:    <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">chan</span> message</span><br></pre></td></tr></table></figure>
<p>这样在低并发下可以正常通过测试，但是在使用脚本测试的时候会出现问题（<strong>已经解决，我认为就是因为高压测试导致的问题</strong>）</p>
<p>channel 的花销肯定是大于正常结构体的，并且还需要关闭 channel， 并且这些 channel 是一次性的，这样 GC 的压力会很大，最初我是使用的 150 个进程同时测试，里面的测试大多数都是至少调用 1000 次，也就是说至少会创建一千次的 channel，并且初始化。由于不熟悉GC，害怕它过慢引发一系列问题 (<em>可以尝试协程池，但我没有实现，后面优化我也把 channel 删除了</em>)</p>
<p>新的定义就是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> message <span class="keyword">struct</span> &#123;</span><br><span class="line">    access   <span class="type">bool</span></span><br><span class="line">    response any</span><br><span class="line">    err      rpc.Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pendingOp <span class="keyword">map</span>[<span class="type">int</span>]message</span><br></pre></td></tr></table></figure>
<p>其实，我写在这里还有个疑惑，就是这样是否能真正的保证线性一致性，因为我是轮询进行返回的，那么如果出现一个延迟就会导致乱序的情况，而且本身map就是无序的，那么这样乱序返回是否会有影响？</p>
<p>这个问题大概让我想了一天，其实本质上就是线性一致性没有理解透。</p>
<p>其实答案是否定的，由上述定义用通俗的话来说就是，你只要保证每个指令逐个向前执行就可以了，不用管谁先来，谁后来。因此 map 是可以承担重任的，并且后面也可以很容易确定 leader 操作（只要看 key 是否存在 map 中即可）。</p>
<blockquote>
<p>线性化是对单个对象上单次操作的保证。它为单个操作集（通常是读取和写入）在单个对象（例如分布式寄存器或数据项）上的行为提供实时（即，墙钟时间）保证。</p>
</blockquote>
<p>如果使用队列那就非常麻烦：</p>
<ol>
<li>如果 rsm 重启，那么持久化的内容就是重新 apply，那么你就需要判断是否需要接收</li>
<li>要保证只能是 leader 接收，因为如果所有的 server 都接收，一是浪费资源，二是队列的 pop 只能是在 submit 中的，如果 old leader carsh，那么新 leader 接管就会被之前未使用的 op 卡住。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Submit a command to Raft, and wait for it to be committed.  It</span></span><br><span class="line"><span class="comment">// should return ErrWrongLeader if client should find new leader and</span></span><br><span class="line"><span class="comment">// try again.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsm *RSM)</span></span> Submit(req any) (rpc.Err, any) &#123;</span><br><span class="line">    <span class="comment">// Submit creates an Op structure to run a command through Raft;</span></span><br><span class="line">    <span class="comment">// for example: op := Op&#123;Me: rsm.me, Id: id, Req: req&#125;, where req</span></span><br><span class="line">    <span class="comment">// is the argument to Submit and id is a unique id for the op.</span></span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">    pprevTerm, isleader := rsm.rf.GetState()</span><br><span class="line">    <span class="keyword">if</span> !isleader &#123;</span><br><span class="line">        <span class="keyword">return</span> rpc.ErrWrongLeader, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    op := Op&#123;</span><br><span class="line">        Me:  rsm.me,</span><br><span class="line">        Req: req,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// lock lock lock !!!</span></span><br><span class="line">    <span class="comment">// 这里必须要锁住，否则会出现已经 apply，但是 index 部分还没有加入到 map 中。</span></span><br><span class="line">    rsm.mu.Lock()</span><br><span class="line">    index, PrevTerm, isleader := rsm.rf.Start(op)</span><br><span class="line">    <span class="keyword">if</span> !isleader || pprevTerm != PrevTerm &#123;</span><br><span class="line">        rsm.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> rpc.ErrWrongLeader, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    rsm.pendingOp[index] = message&#123;&#125;</span><br><span class="line">    rsm.mu.Unlock()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rsm.mu.Lock()</span><br><span class="line">        <span class="built_in">delete</span>(rsm.pendingOp, index)</span><br><span class="line">        rsm.mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 等待 reader 将处理好的数据发送到 map 中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Millisecond)</span><br><span class="line">        rsm.mu.Lock()</span><br><span class="line">        msg, ok := rsm.pendingOp[index]</span><br><span class="line">        rsm.mu.Unlock()</span><br><span class="line">        <span class="keyword">if</span> Term, isleader := rsm.rf.GetState(); !isleader || PrevTerm != Term &#123;</span><br><span class="line">            <span class="keyword">return</span> rpc.ErrWrongLeader, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.LoadInt32(&amp;rsm.dead) == <span class="number">1</span> || !ok &#123;</span><br><span class="line">            rsm.mu.Lock()</span><br><span class="line">            log.Printf(<span class="string">&quot;%v index %v exit map %v&quot;</span>, rsm.me, index, rsm.pendingOp)</span><br><span class="line">            rsm.pendingOp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]message)</span><br><span class="line">            rsm.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span> rpc.ErrShutDown, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        rsm.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> msg.access &amp;&amp; ok &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;[submit] %v -&gt; index %v&quot;</span>, rsm.me, index)</span><br><span class="line">            rsm.mu.Unlock()</span><br><span class="line">            <span class="keyword">return</span> msg.err, msg.response</span><br><span class="line">        &#125;</span><br><span class="line">        rsm.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reader 实现就是照着 raft1/server.go 改的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsm *RSM)</span></span> reader() &#123;</span><br><span class="line">    <span class="keyword">for</span> m := <span class="keyword">range</span> rsm.applyCh &#123;</span><br><span class="line">        <span class="keyword">if</span> m.CommandValid &#123;</span><br><span class="line">            rsm.mu.Lock()</span><br><span class="line">            cmd := m.Command.(Op)</span><br><span class="line">            response := rsm.sm.DoOp(cmd.Req)</span><br><span class="line">            <span class="keyword">if</span> _, ok := rsm.pendingOp[m.CommandIndex]; ok &#123;</span><br><span class="line">                rsm.pendingOp[m.CommandIndex] = message&#123;</span><br><span class="line">                    access:   <span class="literal">true</span>,</span><br><span class="line">                    err:      rpc.OK,</span><br><span class="line">                    response: response,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.Printf(<span class="string">&quot;[reader] %v -&gt; index %v, response %v, persist len %v / %v&quot;</span>, rsm.me, m.CommandIndex, response, rsm.rf.PersistBytes(), rsm.maxraftstate)</span><br><span class="line">            <span class="keyword">if</span> rsm.maxraftstate != <span class="number">-1</span> &amp;&amp; rsm.rf.PersistBytes() &gt;= rsm.maxraftstate &#123;</span><br><span class="line">                snapshot := rsm.sm.Snapshot()</span><br><span class="line">                rsm.rf.Snapshot(m.CommandIndex, snapshot)</span><br><span class="line">            &#125;</span><br><span class="line">            rsm.mu.Unlock()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> m.SnapshotValid &#123;</span><br><span class="line">            rsm.sm.Restore(m.Snapshot)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ignore other conditions</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    atomic.StoreInt32(&amp;rsm.dead, <span class="number">1</span>)</span><br><span class="line">    log.Printf(<span class="string">&quot;%v done&quot;</span>, rsm.me)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lab4b-key-value-service-without-snapshots">Lab4B Key/value service without snapshots</h2>
<p>![[./MIT6_824/Pasted image 20250520182604.png]]<br>
![[./MIT6_824/Pasted image 20250520203202.png]]<br>
![[./MIT6_824/Pasted image 20250520220816.png]]<br>
到这里也算是完全把这个流程搞完了。<br>
![[./MIT6_824/Pasted image 20250520182810.png]]</p>
<h2 id="lab4c-key-value-service-with-snapshots">lab4C Key/value service with snapshots</h2>
<p>![[./MIT6_824/Pasted image 20250521181733.png]]</p>
<p>![[./MIT6_824/Pasted image 20250521192000.png]]</p>
<h3 id="client">client</h3>
<p>这部分和 lab2 中的差不了多少，主要是增加对 leader 查找就可以用了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get fetches the current value and version for a key.  It returns</span></span><br><span class="line"><span class="comment">// ErrNoKey if the key does not exist. It keeps trying forever in the</span></span><br><span class="line"><span class="comment">// face of all other errors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You can send an RPC to server i with code like this:</span></span><br><span class="line"><span class="comment">// ok := ck.clnt.Call(ck.servers[i], &quot;KVServer.Get&quot;, &amp;args, &amp;reply)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The types of args and reply (including whether they are pointers)</span></span><br><span class="line"><span class="comment">// must match the declared types of the RPC handler function&#x27;s</span></span><br><span class="line"><span class="comment">// arguments. Additionally, reply must be passed as a pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> Get(key <span class="type">string</span>) (<span class="type">string</span>, rpc.Tversion, rpc.Err) &#123;</span><br><span class="line">    <span class="comment">// You will have to modify this function.</span></span><br><span class="line">    reply := rpc.GetReply&#123;&#125;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;[client] %v receive key %v, value %v, version %v, seq %v, time %v&quot;</span>, ck.clerkId, key, reply.Value, reply.Version, ck.seq, time.Since(start))</span><br><span class="line">    &#125;()</span><br><span class="line">    atomic.AddInt64(&amp;ck.seq, <span class="number">1</span>)</span><br><span class="line">    args := rpc.GetArgs&#123;Key: key, ClientId: ck.clerkId, SeqNum: ck.seq&#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;[client] %v get key %v&quot;</span>, ck.clerkId, key)</span><br><span class="line">    srv := ck.leaderId</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply = rpc.GetReply&#123;&#125;</span><br><span class="line">        retry := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> !ck.clnt.Call(ck.servers[srv], <span class="string">&quot;KVServer.Get&quot;</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line">        <span class="comment">// 这里面应该是没啥用的，留着就留着把</span></span><br><span class="line">            <span class="keyword">if</span> retry &gt; MAXRETRYNUM &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            retry++</span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(<span class="string">&quot;id %v get reply err %v, srv %v&quot;</span>, ck.clerkId, reply.Err, srv)</span><br><span class="line">        <span class="keyword">if</span> reply.Err == rpc.OK || reply.Err == rpc.ErrNoKey &#123;</span><br><span class="line">            ck.leaderId = srv</span><br><span class="line">            <span class="keyword">return</span> reply.Value, reply.Version, reply.Err</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        srv = (srv + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Put 同理。</p>
<h3 id="sever">sever</h3>
<p>这里面的相较于 lab2 的主要工作是加入了两个变量保证幂等性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    lastApplyied <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int64</span></span><br><span class="line">    lastReplies  <span class="keyword">map</span>[<span class="type">int</span>]any</span><br></pre></td></tr></table></figure>
<ol>
<li>lastapplied 是为了保证每个 client 都是使用的最新的，防止由于网络延迟或者其他原因导致旧的消息被再次执行。</li>
<li>lastReplies 保存了最新的 Put 结果，由于 Get 天生不破坏幂等性，可以不做处理。</li>
</ol>
<p>关于 snapshot 只需要保存以下三个变量即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    db           <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    lastApplyied <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int64</span></span><br><span class="line">    lastReplies  <span class="keyword">map</span>[<span class="type">int</span>]any</span><br></pre></td></tr></table></figure>
<p>另外，进行 snapshot 的时候需要实现进行注册，即在 StartKVServer 的时候加入类似语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    labgob.Register(rpc.GetReply&#123;&#125;)</span><br><span class="line">    labgob.Register(rpc.PutReply&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>![[./MIT6_824/Pasted image 20250529113515.png]]</p>
<h1>Lab 5A: Moving shards</h1>
<p>![[./MIT6_824/Pasted image 20250529113736.png]]<br>
这里标注的是 hard，但是我觉得最难的地方是在于怎么 shard 是什么，怎么去维护 shard 机制。以及这些文件，函数有什么作用，应该怎么调用。</p>
<p>这里说明：</p>
<ol>
<li>grps：指的是 shardgrp 中的 server</li>
<li>grpc：指的是 shardgrp 中的 client</li>
<li>clerk：指的是实际用户调用的部分</li>
</ol>
<p>另外，Lab 5A 其实并没有完全的写完，由于有其它的事情一直耽搁了，后面有空把他补全。</p>
<h2 id="初始化">初始化</h2>
<p>首先，不考虑 shard 的移动，而是想怎么让 grps 获得 shard 信息。怎么让他知道，它是负责哪一块的 shard。</p>
<p>这里我采取的是被动接收， grpc 只管接收来自 clerk 和 controller 的调用。当出现 put 信息的时候进行判断，如果是 <code>version=0</code> 那么就说明这是需要负责的 shard，将相关信息注册到 <code>shardstatemap</code> 中，否则直接返回 wrongGroup。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">state, ok := kv.ShardStateMap[shardID]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">if</span> args.Version == <span class="number">0</span> &#123;</span><br><span class="line">        kv.ShardStateMap[shardID] = shardrpc.WORKING</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.Err = rpc.ErrWrongGroup</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="freezeshard">FreezeShard</h2>
<p>将该 shard 所有相关的信息全部打包，并且将该 shard 标记为 freeze 状态，然后返回。</p>
<h2 id="installshard">InstallShard</h2>
<p>将向对应的 shard 发送给指定的 grpc，标记为 install 状态，然后将相关信息解码，将相关信息添加到相关数据结构即可。</p>
<h2 id="deleteshard">DeleteShard</h2>
<p>将所有与该 shard 的信息全部删除，并且将 shardstate 状态一并删除。</p>
<h2 id="updateconfig">Updateconfig</h2>
<p>这是我自己添加的函数，目的是为了统一更新 grpc 中的 <code>config</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://iuun05.github.io">LiamRyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://iuun05.github.io/2025/07/26/CSDIY/MIT6_824/">http://iuun05.github.io/2025/07/26/CSDIY/MIT6_824/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://iuun05.github.io" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/20220513011040_fc477.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="next-post pull-full" href="/2025/07/26/OS/VirtualMemory/" title="Virtual Memory"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Virtual Memory</div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/20220513011040_fc477.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LiamRyan</div><div class="author-info-description">一个学不会的废物</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/iuun05"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/iuun05" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客部分功能还未完善，后续会陆陆续续完善，请见谅</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Lab1 MapReduce</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#papar"><span class="toc-number">1.1.</span> <span class="toc-text">Papar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.</span> <span class="toc-text">实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#coordinator-go"><span class="toc-number">1.2.1.</span> <span class="toc-text">coordinator.go</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker-go"><span class="toc-number">1.2.2.</span> <span class="toc-text">worker.go</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Lab 2 Key&#x2F;Value Server</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Lab 3 Raft</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.1.</span> <span class="toc-text">专业术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#non-byzantine-byzantine"><span class="toc-number">3.1.1.</span> <span class="toc-text">non-Byzantine &amp; Byzantine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%B5%B7%E6%BA%90"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">问题起源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9E%E8%B4%A8"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">问题实质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.1.3.1.</span> <span class="toc-text">拜占庭容错系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsm-log-structured-merge-tree"><span class="toc-number">3.1.2.</span> <span class="toc-text">LSM（Log Structured Merge Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#log-compact"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">Log Compact</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#size-tiered-compaction"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">size-tiered compaction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#leveled-compaction"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">leveled compaction</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">共识算法特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raft"><span class="toc-number">3.3.</span> <span class="toc-text">Raft</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">3.4.1.</span> <span class="toc-text">基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BA%E8%AF%81"><span class="toc-number">3.4.2.</span> <span class="toc-text">安全性论证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lab3a-leader-election"><span class="toc-number">3.5.1.</span> <span class="toc-text">lab3A leader election</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.1.1.1.</span> <span class="toc-text">初始状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.1.1.2.</span> <span class="toc-text">选举状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%BB%E6%9C%9F%E6%88%96%E8%80%85%E7%8A%B6%E6%80%81%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-number">3.5.1.1.2.1.</span> <span class="toc-text">任期或者状态的更新</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-number">3.5.1.1.2.2.</span> <span class="toc-text">时间的更新</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#vote-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.5.1.1.2.3.</span> <span class="toc-text">Vote 的变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-number">3.5.1.1.2.4.</span> <span class="toc-text">心跳时间选择</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab3b-log"><span class="toc-number">3.5.2.</span> <span class="toc-text">lab3B log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%80%80-appendentries"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">日志的发送与快速回退 AppendEntries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%97%A5%E5%BF%97-commit"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">提交日志 Commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97-apply"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">应用日志 Apply</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab-3c-persist"><span class="toc-number">3.5.3.</span> <span class="toc-text">lab 3C Persist</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">丢包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98-%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">延迟问题（乱序问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8D%9F%E5%9D%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">数据损坏问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%91-error"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">坑（error）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#todo"><span class="toc-number">3.5.3.5.</span> <span class="toc-text">todo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lab4d-snapshot"><span class="toc-number">3.5.4.</span> <span class="toc-text">lab4D snapshot</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">lab4 Fault-tolerant Key Value Service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4a-replicated-state-machine-rsm"><span class="toc-number">4.1.</span> <span class="toc-text">4A replicated state machine (RSM)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab4b-key-value-service-without-snapshots"><span class="toc-number">4.2.</span> <span class="toc-text">Lab4B Key&#x2F;value service without snapshots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab4c-key-value-service-with-snapshots"><span class="toc-number">4.3.</span> <span class="toc-text">lab4C Key&#x2F;value service with snapshots</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#client"><span class="toc-number">4.3.1.</span> <span class="toc-text">client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sever"><span class="toc-number">4.3.2.</span> <span class="toc-text">sever</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Lab 5A: Moving shards</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freezeshard"><span class="toc-number">5.2.</span> <span class="toc-text">FreezeShard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#installshard"><span class="toc-number">5.3.</span> <span class="toc-text">InstallShard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deleteshard"><span class="toc-number">5.4.</span> <span class="toc-text">DeleteShard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#updateconfig"><span class="toc-number">5.5.</span> <span class="toc-text">Updateconfig</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/CSDIY/MIT6_824/" title="MIT 6.824">MIT 6.824</a><time datetime="2025-07-26T13:29:06.000Z" title="发表于 2025-07-26 21:29:06">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/OS/VirtualMemory/" title="Virtual Memory">Virtual Memory</a><time datetime="2025-07-26T13:17:00.000Z" title="发表于 2025-07-26 21:17:00">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/OS/Memory/" title="Memory">Memory</a><time datetime="2025-07-26T13:12:51.000Z" title="发表于 2025-07-26 21:12:51">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/OS/Process_Thread/" title="Process and Thread">Process and Thread</a><time datetime="2025-07-26T13:10:51.000Z" title="发表于 2025-07-26 21:10:51">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/programingLanguage/golang/GMP/" title="GMP">GMP</a><time datetime="2025-07-26T13:06:09.000Z" title="发表于 2025-07-26 21:06:09">2025-07-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By LiamRyan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.0.0-b1"></script><script src="/js/main.js?v=5.0.0-b1"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({svg}) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>